## Abstract
SET：迈心诺信号提取技术(Signah Extraction Technology)
应用的处理方式： 
radiofrequency 
light-shielded optical sensors,
digital signal processing
adaptive filtration
并应用一种新的光吸收概念模型
采取离散饱和变换DST来隔离光通路中的单个饱和分量

运动干扰对于SpO2的测量有较大的影响


## Masimo脉搏血氧仪模型

考虑了由真实动脉信号和一个或者多个运动或者噪声信号贡献的饱和度值。
运动条件下，检测到的IR与RD信号既包括真是动脉饱和度信号，又包含静脉（或者非动脉）运动噪声信号。
![[Pasted image 20231204154421.png]]
IR：归一化脉冲红外信号
RD：归一化脉冲红色信号
S：来自脉动动脉血的IR矢量
M：来自静脉、或非动脉的IR矢量
ra：动脉饱和度对应的光密度比（由此可以得出SpO2）
rv：非动脉饱和度对应的光密度比

常规计算SpO2：RD与IR的比值
Masino：先用（1）和（2）来计算出参考信号RS（reference signal)，之后用AF和DST计算，得出正确的动脉饱和度。

RS的计算：
![[Pasted image 20231204160703.png]]

迭代期间，所有的ra值（这个值对应0-100%的饱和度）都被代替成r'。
RS由上述方式计算之后作为AF（adaptive filter 自适应滤波器）的一个输入。

DST（离散饱和变换）的框图：
![[Pasted image 20231204161653.png]]

RS与IR信号送入AF，这个AF用于识别和消除两个输入信号共同的频率分量
其输出用于建立功率曲线。
这个曲线可以用于识别动脉饱和度的和其他饱和度成分

变量r'是用于确定ra的，ra确定后即可得到SpO2。
确定ra需要由r'扫过与0-100%血氧饱和度相关的全部值。
DST总结表：
![[Pasted image 20231205001925.png]]
## 袁意辉-自适应滤波复现
## 均值滤波

用于滤除低频基线漂移
来源：运动干扰
```%生成噪声
duration = 5;
sample_rate = 100;
freq = 10;
%linspace:在0到5时间范围内生成duration*sample_rate个点作为时间轴
t = linspace(0, duration, duration * sample_rate);
%生成正弦信号
signal = sin(2 * pi * freq * t);
%生成高斯噪声，size(signal)返回了此大小的正态分布随机数列
noise = 0.5 * randn(size(signal));
noisy_signal = signal + noise;
%画图
figure;
plot(t, noisy_signal);
xlabel('Time(s)');
ylabel('Amplitude');

filename = 'noisy.txt';
writematrix(noisy_signal,filename);

%均值滤波
%窗口大小
window_size = 5;
%均值滤波系数
b = (1/window_size) * ones(1,window_size);
%均值滤波
filtered_data = filter(b,1,noise);
plot(noise,'b');
hold on;
plot(filtered_data,'r');
legend('原始数据','降噪后数据');
```
## 低通滤波
用于消除高频电磁干扰，来自环境干扰
设计：matlab自带的滤波器设计即可、
IIR 四阶 ButterWorth
![[Pasted image 20231120151019.png]]
来自Matlab生成：

```
function Hd = lppass_filter
%LPPASS_FILTER 返回离散时间滤波器对象。

% MATLAB Code
% Generated by MATLAB(R) 9.10 and Signal Processing Toolbox 8.6.
% Generated on: 20-Nov-2023 15:12:19

% Butterworth Lowpass filter designed using FDESIGN.LOWPASS.

% All frequency values are in Hz.
Fs = 100;  % Sampling Frequency

N  = 4;  % Order
Fc = 6;  % Cutoff Frequency

% Construct an FDESIGN object and call its BUTTER method.
h  = fdesign.lowpass('N,F3dB', N, Fc, Fs);
Hd = design(h, 'butter');

% [EOF]
```

## 基于LMS自适应滤波
```
%****************************************************************************************
%
%                      创建两个信号Mix_Signal_1 和信号 Mix_Signal_2
%
%***************************************************************************************
 
Fs = 1000; %采样率
N = 1000; %采样点数
n = 0:N - 1;
t = 0:1 / Fs:(N - 1) / Fs; %时间序列
Signal_Original_1 = sin(2 * pi * 10 * t) + sin(2 * pi * 20 * t) + sin(2 * pi * 30 * t);
Noise_White_1 = [0.3 * randn(1, 500), rand(1, 500)]; %前500点高斯分部白噪声，后500点均匀分布白噪声
Mix_Signal_1 = Signal_Original_1 + Noise_White_1; %构造的混合信号
 
Signal_Original_2 = [zeros(1, 100), 20 * ones(1, 20), -2 * ones(1, 30), 5 * ones(1, 80), -5 * ones(1, 30), 9 * ones(1, 140), -4 * ones(1, 40), 3 * ones(1, 220), 12 * ones(1, 100), 5 * ones(1, 20), 25 * ones(1, 30), 7 * ones(1, 190)];
Noise_White_2 = 0.5 * randn(1, 1000); %高斯白噪声
Mix_Signal_2 = Signal_Original_2 + Noise_White_2; %构造的混合信号

%混合信号 Mix_Signal_1 自适应滤波
figure(6);
N=1000;                                            %输入信号抽样点数N
k=100;                                             %时域抽头LMS算法滤波器阶数
u=0.001;                                           %步长因子
 
%设置初值
yn_1=zeros(1,N);                                  %output signal
yn_1(1:k)=Mix_Signal_1(1:k);                %将输入信号SignalAddNoise的前k个值作为输出yn_1的前k个值
w=zeros(1,k);                                        %设置抽头加权初值
e=zeros(1,N);                                        %误差信号
 
%用LMS算法迭代滤波
for i=(k+1):N
        XN=Mix_Signal_1((i-k+1):(i));
        yn_1(i)=w*XN';
        e(i)=Signal_Original_1(i)-yn_1(i);
        w=w+2*u*e(i)*XN;
end
subplot(4,1,1);
plot(Mix_Signal_1);                              %Mix_Signal_1 原始信号
axis([k+1,1000,-4,4]);
title('原始信号1');
subplot(4,1,2);
plot(yn_1);                                            %Mix_Signal_1 自适应滤波后信号
axis([k+1,1000,-4,4]);
title('自适应滤波后信号1');
%混合信号 Mix_Signal_2 自适应滤波
N=1000;                                            %输入信号抽样点数N
k=500;                                                %时域抽头LMS算法滤波器阶数
u=0.000011;                                        %步长因子
%设置初值
yn_1=zeros(1,N);                                  %output signal
yn_1(1:k)=Mix_Signal_2(1:k);                  %将输入信号SignalAddNoise的前k个值作为输出yn_1的前k个值
w=zeros(1,k);                                        %设置抽头加权初值
e=zeros(1,N);                                        %误差信号
%用LMS算法迭代滤波
for i=(k+1):N
        XN=Mix_Signal_2((i-k+1):(i));
        yn_1(i)=w*XN';
        e(i)=Signal_Original_2(i)-yn_1(i);
        w=w+2*u*e(i)*XN;
end
 
subplot(4,1,3);
plot(Mix_Signal_2);                              %Mix_Signal_1 原始信号
axis([k+1,1000,-10,30]);
title('原始信号2');
 
subplot(4,1,4);
plot(yn_1);                                            %Mix_Signal_1 自适应滤波后信号
axis([k+1,1000,-10,30]);
title('自适应滤波后信号2');
```
效果图如下：
![[Pasted image 20231120160954.png]]
核心部分：
```
%用LMS算法迭代滤波
for i=(k+1):N
    %确定窗口数据
        XN=Mix_Signal_1((i-k+1):(i));
    %滤波
        yn_1(i)=w*XN';
    %计算误差
        e(i)=Signal_Original_1(i)-yn_1(i);
    %迭代加权系数
        w=w+2*u*e(i)*XN;
end
```



